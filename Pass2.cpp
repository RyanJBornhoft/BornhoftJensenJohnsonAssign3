#include <iostream>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <string>
#include <vector>
#include <map>
#include <algorithm>
#include <cctype>
#include "OpcodeTable.h"
#include <set>

using namespace std;

static string trim(const string &s) {
    size_t b = s.find_first_not_of(" \t\r\n");
    if (b == string::npos) return "";
    size_t e = s.find_last_not_of(" \t\r\n");
    return s.substr(b, e - b + 1);
}
static string upper(string s){ for(char &c:s) c = toupper((unsigned char)c); return s; }
static bool isDigits(const string &s){ if(s.empty()) return false; for(char c:s) if(!isdigit((unsigned char)c)) return false; return true; }

// Listing line model
struct Line {
    int lineNum = 0;
    int locctr  = 0;  // parsed from hex
    string label;     // may be "" or "*"
    string op;        // uppercase mnemonic or directive
    string operand;   // raw operand (e.g., =C'ABCD', @RETADR)
    bool isLiteral = false; // label == "*"
    string obj;       // generated object code (hex, no spaces)
    int sizeBytes = 0; // length of generated bytes (or reserved)
};

// Register numbers (SIC/XE)
static int regNum(string r) {
    r = upper(trim(r));
    if (r == "A")  return 0;
    if (r == "X")  return 1;
    if (r == "L")  return 2;
    if (r == "B")  return 3;
    if (r == "S")  return 4;
    if (r == "T")  return 5;
    if (r == "F")  return 6;
    if (r == "PC") return 8;
    if (r == "SW") return 9;
    return -1;
}

// Parse a listing line from .int
static bool parseListing(const string &raw, Line &out) {
    string s = trim(raw);
    if (s.empty()) return false;
    if (s.rfind("LINE#", 0) == 0) return false;

    istringstream iss(s);
    string lnTok, locTok, t1;
    if (!(iss >> lnTok)) return false;
    if (!isDigits(lnTok)) return false;
    if (!(iss >> locTok)) return false;
    if (!(iss >> t1)) return false;

    string label, op;
    if (!t1.empty() && (t1 == "*" || t1.back() == ':')) {
        label = t1;
        if (!(iss >> op)) op.clear();
    } else {
        op = t1;
    }

    string rest; getline(iss, rest);
    out.lineNum = stoi(lnTok);
    out.locctr  = stoi(locTok, nullptr, 16);
    out.label   = label;
    out.op      = upper(op);
    out.operand = trim(rest);
    out.isLiteral = (label == "*");
    return !out.op.empty();
}

// Fix parseLiteral (ensure correct value for =C'ABCD')
static bool parseLiteral(const std::string &lit, std::string &hex, int &bytes) {
    hex.clear(); bytes = 0;
    if (lit.size() < 4 || lit[0] != '=') return false;
    char kind = std::toupper((unsigned char)lit[1]);
    size_t first = lit.find('\'');
    size_t last  = lit.rfind('\'');
    if (first == std::string::npos || last == std::string::npos || last <= first) return false;
    std::string body = lit.substr(first+1, last-first-1);
    if (kind=='C') {
        std::ostringstream oss;
        for (unsigned char ch : body)
            oss << std::uppercase << std::hex << std::setw(2) << std::setfill('0') << int(ch);
        hex = oss.str();
        bytes = (int)body.size();
        return true;
    } else if (kind=='X') {
        std::string h = body;
        for (char &c : h) c = std::toupper((unsigned char)c);
        hex = h;
        bytes = (int)((h.size()+1)/2);
        return true;
    }
    return false;
}

static bool isNumber(const string &s) {
    if (s.empty()) return false;
    size_t i = 0;
    if (s[0]=='+'||s[0]=='-') i=1;
    for (; i<s.size(); ++i) if (!isdigit((unsigned char)s[i])) return false;
    return true;
}

static string toHex(int v, int width) {
    ostringstream oss; oss << uppercase << hex << setw(width) << setfill('0') << (v & ((1<<(4*width))-1));
    return oss.str();
}

/********************************************************************
*** FUNCTION addErr
*********************************************************************
*** DESCRIPTION : Append a formatted error message to the global
***               error list. If lineNum > 0, prefixes "Line <n>: ".
*** INPUT ARGS : lineNum  - source line number (or <=0 for none)
***              msg      - human-readable error message
*** OUTPUT ARGS : none
*** IN/OUT ARGS : none
*** RETURN : void
********************************************************************/

// Add global error accumulator
static std::vector<std::string> g_errors;
static void addErr(int lineNum, const std::string &msg) {
    std::ostringstream oss;
    if (lineNum > 0) oss << "Line " << lineNum << ": " << msg;
    else oss << msg;
    g_errors.push_back(oss.str());
}

/********************************************************************
*** FUNCTION splitCSV
*********************************************************************
*** DESCRIPTION : Split a comma-separated operand list (e.g., for
***               EXTDEF/EXTREF) into trimmed, uppercased tokens.
*** INPUT ARGS : s - raw comma-separated string
*** OUTPUT ARGS : none
*** IN/OUT ARGS : none
*** RETURN : std::vector<std::string> - tokens in order
********************************************************************/
static std::vector<std::string> splitCSV(const std::string& s) {
    std::vector<std::string> out; std::string cur;
    for(char c: s){
        if(c==','){ std::string t=trim(cur); if(!t.empty()) out.push_back(upper(t)); cur.clear(); }
        else cur.push_back(c);
    }
    std::string t=trim(cur); if(!t.empty()) out.push_back(upper(t));
    return out;
}

/********************************************************************
*** FUNCTION printErrorCategorySummary
*********************************************************************
*** DESCRIPTION : Print a one-line categorized error summary counting
***               common error types collected during Pass 2.
*** INPUT ARGS : none
*** OUTPUT ARGS : none
*** IN/OUT ARGS : none
*** RETURN : void
********************************************************************/
static void printErrorCategorySummary() {
    int undef=0, illegal=0, range=0, unknown=0, badreg=0;
    for (auto &e : g_errors) {
        if (e.find("Undefined symbol") != std::string::npos) ++undef;
        else if (e.find("Illegal") != std::string::npos) ++illegal;
        else if (e.find("out of range") != std::string::npos) ++range;
        else if (e.find("Unknown mnemonic") != std::string::npos) ++unknown;
        else if (e.find("register") != std::string::npos) ++badreg;
    }
    if (!g_errors.empty()) {
        std::cout << "\nError summary: "
                  << "undefined=" << undef << ", illegal=" << illegal
                  << ", out_of_range=" << range << ", unknown_mnemonic=" << unknown
                  << ", bad_register=" << badreg << "\n";
    }
}

/********************************************************************
*** FUNCTION displayFile
*********************************************************************
*** DESCRIPTION : Print a titled section to stdout followed by the
***               entire contents of a file (used for listing/object).
*** INPUT ARGS : title    - section header to print
***              filename - path to the file to display
*** OUTPUT ARGS : none
*** IN/OUT ARGS : none
*** RETURN : void
********************************************************************/
static void displayFile(const std::string &title, const std::string &filename) {
    std::ifstream in(filename);
    if (!in.is_open()) return;
    std::cout << "\n" << title << "\n";
    std::string line;
    while (std::getline(in, line)) std::cout << line << "\n";
    in.close();
}

/********************************************************************
*** FUNCTION genObj
*********************************************************************
*** DESCRIPTION : Generate object code for one assembled line. Handles:
***               - Directives: WORD/BYTE/RESW/RESB/Literals
***               - Formats 1/2/3/4 (uses OpcodeTable)
***               - Addressing modes: immediate(@/#), indirect, indexed
***               - PC-relative and BASE-relative displacement selection
***               - Format 4 absolute target handling
*** INPUT ARGS : symaddr - symbol table (LABEL -> address)
***              litaddr - literal table (token -> address)
***              optab   - opcode/format lookup
***              baseReg - BASE register value, or -1 if inactive
*** OUTPUT ARGS : none
*** IN/OUT ARGS : L - line to annotate with obj code and sizeBytes
*** RETURN : void
********************************************************************/
static void genObj(Line &L,
                   const std::map<std::string,int> &symaddr,
                   const std::map<std::string,int> &litaddr,
                   const OpcodeTable& optab,
                   int baseReg)
{
    L.obj.clear(); L.sizeBytes = 0;
    if (L.op=="START"||L.op=="END"||L.op=="EQU"||L.op=="BASE"||L.op=="NOBASE"||
        L.op=="EXTDEF"||L.op=="EXTREF"||L.op=="CSECT") return;
    if (L.op=="RESW"){ L.sizeBytes = (isNumber(L.operand)? stoi(L.operand)*3:0); return; }
    if (L.op=="RESB"){ L.sizeBytes = (isNumber(L.operand)? stoi(L.operand):0);  return; }
    if (L.op=="WORD"){
        int v=0;
        if(isNumber(L.operand)) v=stoi(L.operand);
        else {
            auto it=symaddr.find(upper(L.operand));
            if(it!=symaddr.end()) v=it->second;
            else addErr(L.lineNum,"Undefined symbol in WORD: "+L.operand);
        }
        std::ostringstream oc; oc<<std::uppercase<<std::hex<<std::setw(6)<<std::setfill('0')<<(v&0xFFFFFF);
        L.obj=oc.str(); L.sizeBytes=3; return;
    }
    if (L.op=="BYTE"){
        std::string hv; int bl=0;
        if(parseLiteral("="+L.operand,hv,bl)){ L.obj=hv; L.sizeBytes=bl; }
        else addErr(L.lineNum,"Invalid BYTE operand: "+L.operand);
        return;
    }
    if (L.isLiteral){
        std::string hv; int bl=0;
        if(parseLiteral(L.op,hv,bl)){ L.obj=hv; L.sizeBytes=bl; }
        else addErr(L.lineNum,"Invalid literal: "+L.op);
        return;
    }
    bool fmt4 = (!L.op.empty() && L.op[0]=='+');
    std::string baseOp = fmt4? L.op.substr(1): L.op;
    if(!optab.exists(baseOp)){ addErr(L.lineNum,"Unknown mnemonic: "+baseOp); return; }
    int fmt = fmt4?4:optab.getFormat(baseOp);
    int opcode = optab.getOpcode(baseOp);

    if(fmt==1){
        std::ostringstream oc; oc<<std::uppercase<<std::hex<<std::setw(2)<<std::setfill('0')<<opcode;
        L.obj=oc.str(); L.sizeBytes=1; return;
    }
    if(fmt==2){
        int r1=-1,r2=0;
        size_t c=L.operand.find(',');
        if(c==std::string::npos) r1=regNum(L.operand);
        else { r1=regNum(L.operand.substr(0,c)); r2=regNum(L.operand.substr(c+1)); }
        if(r1<0||r2<0){ addErr(L.lineNum,"Invalid register in format 2: "+L.operand); return; }
        std::ostringstream oc; oc<<std::uppercase<<std::hex<<std::setw(2)<<std::setfill('0')<<opcode
                                 <<std::setw(1)<<r1<<std::setw(1)<<r2;
        L.obj=oc.str(); L.sizeBytes=2; return;
    }

    bool immediate=false, indirect=false, indexed=false;
    std::string targ=trim(L.operand);
    if(!targ.empty()&&targ[0]=='#'){ immediate=true; targ=targ.substr(1); }
    else if(!targ.empty()&&targ[0]=='@'){ indirect=true; targ=targ.substr(1); }
    size_t comma=targ.find(',');
    if(comma!=std::string::npos){
        std::string r=trim(targ.substr(comma+1));
        if(upper(r)=="X") indexed=true;
        targ=trim(targ.substr(0,comma));
    }
    int targetAddr=0; bool targetKnown=false;
    if(!L.operand.empty() && L.operand[0]=='='){
        auto litIt=litaddr.find(L.operand);
        if(litIt!=litaddr.end()){ targetAddr=litIt->second; targetKnown=true; }
        else addErr(L.lineNum,"Literal not found: "+L.operand);
    } else if(immediate && isNumber(targ)){
        targetAddr=stoi(targ); targetKnown=true;
    } else if(!targ.empty()){
        auto si=symaddr.find(upper(targ));
        if(si!=symaddr.end()){ targetAddr=si->second; targetKnown=true; }
        else addErr(L.lineNum,"Undefined symbol: "+targ);
    }
    int nBit,iBit;
    if(immediate && isNumber(targ)){ nBit=0; iBit=1; }
    else if(immediate && !indirect){ nBit=1; iBit=1; }
    else if(indirect && !immediate){ nBit=1; iBit=0; }
    else { nBit=1; iBit=1; }
    int xbpe=0; if(indexed) xbpe|=0x8;
    int first=(opcode & 0xFC) | ((nBit<<1)|iBit);

    if(fmt==4){
        if(!targetKnown){ addErr(L.lineNum,"Format 4 operand unknown: "+L.operand); return; }
        xbpe|=0x1;
        int disp= targetAddr & 0xFFFFF;
        std::ostringstream oc;
        oc<<std::uppercase<<std::hex<<std::setw(2)<<std::setfill('0')<<first
          <<std::setw(2)<<((xbpe<<4)|((disp>>16)&0xF))
          <<std::setw(2)<<((disp>>8)&0xFF)
          <<std::setw(2)<<(disp & 0xFF);
        L.obj=oc.str(); L.sizeBytes=4; return;
    }

    int disp=0;
    if(immediate && isNumber(targ)){
        disp = targetAddr & 0xFFF;
    } else if(targetKnown){
        int pc = L.locctr + 3;
        int d  = targetAddr - pc;
        if(d >= -2048 && d <= 2047){
            xbpe |= 0x2; disp = d & 0xFFF;
        } else if(baseReg >=0){
            int bdisp = targetAddr - baseReg;
            if(bdisp >=0 && bdisp <= 4095){ xbpe|=0x4; disp=bdisp & 0xFFF; }
            else { addErr(L.lineNum,"Address out of range (PC/BASE): "+L.operand); return; }
        } else {
            addErr(L.lineNum,"Address out of range (PC) and no BASE set: "+L.operand); return;
        }
    }
    std::ostringstream oc;
    oc<<std::uppercase<<std::hex<<std::setw(2)<<std::setfill('0')<<first
      <<std::setw(2)<<((xbpe<<4)|((disp>>8)&0xF))
      <<std::setw(2)<<(disp & 0xFF);
    L.obj=oc.str(); L.sizeBytes=3;
}

/********************************************************************
*** FUNCTION main
*********************************************************************
*** DESCRIPTION : Pass 2 driver. Reads the intermediate (.int), rebuilds
***               tables, generates object code per line, emits H/T/E
***               records (and D/R if enabled), writes the listing and
***               object files, and prints any errors.
*** INPUT ARGS : argc - argument count (expects 2: program and .int path)
***              argv - argument vector
*** OUTPUT ARGS : none
*** IN/OUT ARGS : none
*** RETURN : int - 0 on success; non-zero on failure
********************************************************************/

int main(int argc, char* argv[]) {
    if (argc < 2) {
        cerr << "Usage: Pass2 <intermediate.int>\n";
        return 1;
    }
    string intFile = argv[1];

    ifstream in(intFile);
    if (!in) { cerr << "Cannot open " << intFile << "\n"; return 1; }

    cout << "========== PASS 2 - SIC/XE ASSEMBLER ==========\n";
    cout << "Processing file: " << intFile << "\n\n";

    vector<Line> lines;
    string raw;
    while (getline(in, raw)) {
        Line L;
        if (parseListing(raw, L)) lines.push_back(L);
    }
    in.close();

    int startAddr = 0;
    string programName = "PROG";
    for (auto &L : lines) {
        if (L.op == "START") {
            startAddr = L.locctr;
            if (!L.label.empty()) {
                programName = L.label;
                if (!programName.empty() && programName.back() == ':')
                    programName.pop_back();
            }
            break;
        }
    }

    // Build symbol map (strip colon, uppercase)
    map<string,int> symaddr;
    for (auto &L : lines) {
        if (!L.label.empty() && L.label != "*") {
            string name = L.label;
            if (!name.empty() && name.back()==':') name.pop_back();
            symaddr[upper(name)] = L.locctr;
            if (L.op=="START") programName = name;
        }
        if (L.op=="START") startAddr = L.locctr;
    }

    // BASE register tracking
    int baseReg = -1;

    // Build literal address map (operand string key)
    map<string,int> litaddr;
    for (auto &L : lines)
        if (L.isLiteral)
            litaddr[L.op] = L.locctr;

    OpcodeTable optab;

    // ADD: keep these in scope for the whole function
    std::vector<std::string> extdefs;
    std::vector<std::string> extrefs;

    // Generate object code with directive handling
    for (auto &L : lines) {
        if (L.op=="BASE") {
            auto si = symaddr.find(upper(L.operand));
            if (si != symaddr.end()) baseReg = si->second;
            else addErr(L.lineNum,"BASE undefined symbol: " + L.operand);
            continue;
        }
        if (L.op=="NOBASE") { baseReg = -1; continue; }
        if (L.op=="EXTDEF") { auto v = splitCSV(L.operand); extdefs.insert(extdefs.end(), v.begin(), v.end()); continue; }
        if (L.op=="EXTREF") { auto v = splitCSV(L.operand); extrefs.insert(extrefs.end(), v.begin(), v.end()); continue; }
        if (L.op=="CSECT")  { addErr(L.lineNum,"CSECT encountered: multi-section not supported (stub)"); continue; }

        genObj(L, symaddr, litaddr, optab, baseReg);
    }

    // Compute program length (exclude EQU absolute values)
    int progLen = 0;
    {
        int maxLocPlusSize = startAddr;
        for (auto &L : lines) {
            int sz = 0;
            if (!L.obj.empty()) sz = (int)L.obj.size()/2;
            else if (L.op=="RESW") sz = (isDigits(L.operand)? stoi(L.operand)*3:0);
            else if (L.op=="RESB") sz = (isDigits(L.operand)? stoi(L.operand):0);
            else if (L.isLiteral) sz = L.sizeBytes;
            int candidate = L.locctr + sz;
            if (candidate > maxLocPlusSize) maxLocPlusSize = candidate;
        }
        progLen = maxLocPlusSize - startAddr;
        // Override with END locctr + trailing literal sizes if END present (matches pass1)
        int endLoc = -1;
        for (auto &L : lines) if (L.op=="END") endLoc = L.locctr;
        if (endLoc >= 0) {
            int tailSize = 0;
            for (auto &L : lines) if (L.isLiteral && L.locctr >= endLoc) tailSize += L.sizeBytes;
            progLen = (endLoc - startAddr) + tailSize;
        }
    }

    // Listing file
    string listFileName = "test.txt";
    ofstream lst(listFileName);

    // Header
    lst << std::left
        << std::setw(6)  << "LINE#"   // gives a trailing space
        << std::setw(8)  << "LOCCTR"
        << std::setw(8)  << "LABEL"
        << std::setw(11) << "OPERATION"
        << std::setw(13) << "OPERAND"
        << "OBJCODE\n";

    // Rows
    for (auto &L : lines) {
        // LINE# (decimal, 2 digits, right-aligned)
        lst << std::right << std::dec
            << std::setw(2) << std::setfill('0') << L.lineNum
            << std::setfill(' ') << "   ";

        // LOCCTR (hex, 5 digits, right-aligned)
        lst << std::uppercase << std::hex
            << std::setw(5) << std::setfill('0') << (L.locctr & 0xFFFFF)
            << std::setfill(' ') << "  ";

        // LABEL, OPERATION, OPERAND (left)
        lst << std::left  << std::setw(8)  << (L.label.empty() ? "" : L.label)
            << std::left  << std::setw(11) << L.op
            << std::left  << std::setw(13) << L.operand;

        // OBJCODE
        lst << L.obj << "\n";
    }

    // Footer: Program Length in hex (to match header)
    lst << "\nProgram Length = "
        << std::uppercase << std::hex << progLen
        << std::dec << "\n";

    lst.close();

    // Object file header uses hex program length
    string objFileName = "test.obj";
    ofstream obj(objFileName);
    obj << "H^" << programName << "^" << toHex(startAddr,6) << "^" << toHex(progLen,6) << "\n";

    // Emit D/R records (after H, before T)
    if (!extdefs.empty()) {
        obj << "D";
        for (const auto &name : extdefs) {
            obj << "^" << name;
            auto it = symaddr.find(name);
            obj << "^" << toHex((it==symaddr.end()?0:it->second), 6);
        }
        obj << "\n";
    }
    if (!extrefs.empty()) {
        obj << "R";
        for (const auto &name : extrefs) obj << "^" << name;
        obj << "\n";
    }

    // Text record batching (emit ^ between each object code in the record)
    const int MAX_TEXT = 30;
    auto flush = [&](int &recStart, int &recLen, std::vector<std::string> &fields){
        if (recLen==0) return;
        obj << "T^" << toHex(recStart,6) << "^" << toHex(recLen,2);
        for (const auto &f : fields) obj << "^" << f;
        obj << "\n";
        fields.clear(); recLen = 0; recStart = -1;
    };

    int recStart = -1, recLen = 0, prevEnd = -1;
    std::vector<std::string> fields;

    for (auto &L : lines) {
        if (L.obj.empty()) {                 // gaps/directives force flush
            flush(recStart, recLen, fields);
            prevEnd = -1;
            continue;
        }
        int bytes = (int)L.obj.size()/2;
        bool gap = (prevEnd!=-1 && L.locctr != prevEnd);
        bool overflow = (recLen + bytes > MAX_TEXT);
        if (recStart==-1 || gap || overflow) {
            flush(recStart, recLen, fields);
            recStart = L.locctr;
        }
        fields.push_back(L.obj);             // keep each objcode as its own field
        recLen += bytes;
        prevEnd = L.locctr + bytes;
    }
    flush(recStart, recLen, fields);

    obj << "E^" << toHex(startAddr,6) << "\n";
    obj.close();

    cout << "Listing file written to: " << listFileName << "\n";
    cout << "Object file written to: " << objFileName << "\n\n";

    // Append Symbol & Literal tables
    {
        std::ofstream lstApp(listFileName, std::ios::app);

        // Compute flags (default: relocatable=1, defined=1, modification=0)
        struct Flags { int r; int i; int m; Flags(int rr=1,int ii=1,int mm=0):r(rr),i(ii),m(mm){} };
        std::map<std::string, Flags> flags;
        for (const auto &p : symaddr) flags[p.first] = Flags();

        // Refine flags for EQU lines
        for (const auto &L : lines) {
            if (L.op == "EQU" && !L.label.empty()) {
                std::string lab = upper(L.label);
                if (!lab.empty() && lab.back()==':') lab.pop_back();

                std::string opnd = trim(L.operand);
                int r = 1; // relocatable by default

                if (opnd == "*") {
                    r = 1; // current location is relocatable
                } else if (isNumber(opnd)) {
                    r = 0; // absolute constant
                } else {
                    // Simple expression: sym - sym => absolute
                    size_t dash = opnd.find('-');
                    if (dash != std::string::npos) {
                        std::string a = upper(trim(opnd.substr(0,dash)));
                        std::string b = upper(trim(opnd.substr(dash+1)));
                        if (!a.empty() && !b.empty() && symaddr.count(a) && symaddr.count(b)) r = 0;
                    } else {
                        // Single symbol => relocatable
                        r = 1;
                    }
                }
                flags[lab] = Flags(r, 1, 0);
            }
        }

        // Symbol Table (match Pass 1)
        lstApp << "\nSymbol Table\n";
        lstApp << std::left  << std::setw(10) << "LABEL"
               << std::left  << std::setw(8)  << "VALUE"
               << std::left  << std::setw(7)  << "RFLAG"
               << std::left  << std::setw(7)  << "IFLAG"
               << std::left  << std::setw(7)  << "MFLAG" << "\n";

        // Alphabetical by label
        std::vector<std::string> names;
        names.reserve(symaddr.size());
        for (const auto &p : symaddr) names.push_back(p.first);
        std::sort(names.begin(), names.end(),
                  [](const std::string& a, const std::string& b){ return a < b; });

        for (const auto &name : names) {
            int addr = symaddr.at(name) & 0xFFFFF;
            const Flags &f = flags[name];

            std::ostringstream v; v << std::uppercase << std::hex << addr; // no zero pad
            lstApp << std::left  << std::setw(10) << name
                   << std::left  << std::setw(8)  << v.str()
                   << std::left  << std::setw(7)  << f.r
                   << std::left  << std::setw(7)  << f.i
                   << std::left  << std::setw(7)  << f.m
                   << "\n";
        }

        // Literal Table (ADDR width 5, like your listing)
        lstApp << "\nLiteral Table\n";
        lstApp << std::left  << std::setw(12) << "LITERAL"
               << std::left  << std::setw(10) << "VALUE"
               << std::right << std::setw(5)  << "LEN"
               << ' ' << std::right << std::setw(5)  << "ADDR" << "\n";

        for (const auto &L : lines) if (L.isLiteral) {
            std::string hv; int bl=0;
            if (parseLiteral(L.op, hv, bl)) {
                lstApp << std::left  << std::setw(12) << L.op
                       << std::left  << std::setw(10) << hv
                       << std::right << std::setw(5)  << std::dec << bl
                       << ' ' << std::right << std::uppercase << std::hex
                       << std::setw(5) << std::setfill('0') << (L.locctr & 0xFFFFF)
                       << std::setfill(' ') << std::dec << "\n";
            }
        }
    }

    // Now print the full listing (including the appended tables) to screen
    displayFile("===================Listing File===================", listFileName);

    // Then print the object program
    displayFile("===========Object Program File===========", objFileName);

    // Screen error summary
    if (!g_errors.empty()) {
        printErrorCategorySummary();
        std::cout << "\nErrors (" << g_errors.size() << "):\n";
        for (auto &e : g_errors) std::cout << "  " << e << "\n";
    } else {
        std::cout << "\nNo Pass 2 errors detected.\n";
    }

    std::cout << "\n========== PASS 2 COMPLETE ==========\n";
    return 0;
}